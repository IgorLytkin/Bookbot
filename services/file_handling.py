# Реализуйте функцию _get_part_text(), которая принимает три аргумента в следующем порядке:
#   text - строка с полным текстом, из которого нужно получить страницу не больше заданного размера
#   start - номер первого символа в тексте, с которого должна начинаться страница (нумерация идет с нуля)
#   page_size - максимальный размер страницы, которая должна получиться на выходе

# Функция должна вернуть текст страницы (тип str) и ее получившийся размер в символах (тип int).

# Список знаков препинания, которые могут быть окончанием текста страницы, состоит из знаков:
#   , - запятая
#   . - точка
#   ! - восклицательный знак
#   : - двоеточие
#   ; - точка с запятой
#   ? - вопросительный знак

# Примечание 1. Гарантируется, что подаваемый в функцию текст, не пустой, а в тексте страницы обязательно встретятся
# знаки препинания из списка выше

# Примечание 2. Также гарантируется, что стартовый символ будет меньше, чем длина подаваемого в функцию текста.

# Примечание 3. Если в тексте встречается многоточие (а также другие сочетания идущих подряд знаков препинания,
# типа, ?!, ?.., !.. и т.п.) - они либо целиком должны попасть в текущую страницу, либо не попасть в страницу вообще.
# Нельзя разорвать такую последовательность, потому что следующая страница книги тогда начнется с точки, точек или
# других знаков препинания, что для пользователя будет смотреться, как неправильное форматирование текста.

# Примечание 4. Обрезать невидимые символы (перенос строки, пробел и т.п.), получившиеся слева от текста, не надо.

def _get_part_text(text: str, start: int, page_size: int):
    stop_symbols: str = ',.!:;?' # знаки препинания
    len_text = len(text)
    # Особый случай 1 - последняя страница текста, возвращаем остаток text от start до конца text
    if start + page_size > len_text:
        len_result = len_text - page_size
    # Проверяем последний символ страницы на принадлежность множеству стоп-символов
    elif text[start+page_size-1 : start+page_size] in stop_symbols:
        len_result = page_size
    else: # если последний символ страницы это обычный символ, то идём влево до любого из стоп-символов или пробела
        len_result = page_size
        while text[start+len_result-1: start+len_result] not in stop_symbols:
                len_result -= 1
    return text[start:len_result], len_result

# Тесты
text = '0123456789 01234567890 123456789'
print(*_get_part_text(text, 0, 20), sep='\n')

text = 'Раз. Два. Три. Четыре. Пять. Прием!'
print(*_get_part_text(text, 5, 9), sep='\n')

text = ('Да? Вы точно уверены? Может быть, вам это показалось?.. Ну, хорошо, приходите завтра, тогда и посмотрим, что '
        'можно сделать. И никаких возражений! Завтра, значит, завтра!')
print(*_get_part_text(text, 22, 145), sep='\n')

text = ('— Я всё очень тщательно проверил, — сказал компьютер, — и со всей определённостью заявляю, что это и есть ответ. '
        'Мне кажется, если уж быть с вами абсолютно честным, то всё дело в том, что вы сами не знали, в чём вопрос.')
print(*_get_part_text(text, 54, 70), sep='\n')
